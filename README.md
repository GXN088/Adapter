# Adapter

## Реализация:

1. **Определите интерфейсы**:
   - Целевой интерфейс (`RowItem`) - какой интерфейс вам нужен
   - Адаптируемые интерфейсы (`Customer` и `Contact`) - что у вас есть

2. **Создайте класс-адаптер**:
   - Реализуйте целевой интерфейс
   - Добавьте поля для хранения адаптируемых объектов
   - Создайте конструктор для их инициализации

3. **Реализуйте методы адаптера**:
   - Для каждого метода целевого интерфейса определите:
     * Откуда брать данные (какой из адаптируемых объектов)
     * Какие преобразования нужны
   - Примеры преобразований:
     * Поиск кода страны по названию
     * Разделение полного имени на части
     * Очистка номера телефона от лишних символов

4. **Использование адаптера**:
   - Клиентский код работает только с `RowItem`
   - Адаптер скрывает все преобразования и работу с разными интерфейсами

Такой подход особенно полезен при:
- Интеграции с внешними библиотеками
- Рефакторинге устаревшего кода
- Согласовании интерфейсов разных модулей системы

# Анализ кода задачи "Закрепляем адаптер"

Этот код демонстрирует паттерн "Адаптер" (Adapter), который позволяет интерфейсам работать вместе, когда они изначально несовместимы.

## Объяснение кода:

1. **Статическая карта countries**:
   ```java
   public static Map<String, String> countries = new HashMap<String, String>();
   ```
   Содержит соответствия кодов стран (UA, RU, CA) их полным названиям. Инициализируется в статическом блоке.

2. **Интерфейсы**:
   - `RowItem` - целевой интерфейс, который мы хотим получить
   - `Customer` и `Contact` - существующие интерфейсы, которые нужно адаптировать

3. **Класс DataAdapter**:
   Это собственно адаптер, который реализует целевой интерфейс `RowItem` и использует объекты `Customer` и `Contact` для получения данных.

## Методы адаптера:

1. **getCountryCode()**:
   - Ищет в карте countries код страны по её полному названию из Customer
   - Возвращает код (например, "UA" для "Ukraine")

2. **getCompany()**:
   - Просто возвращает название компании из Customer

3. **getContactFirstName()** и **getContactLastName()**:
   - Разбивают строку имени из Contact (формат "Фамилия, Имя")
   - Возвращают соответствующую часть

4. **getDialString()**:
   - Форматирует телефонный номер из Contact
   - Удаляет все нецифровые символы (`\\D`)
   - Добавляет префикс "callto://+"

## Как додуматься до такого решения:

1. **Анализ требований**:
   - Нужно получить данные из двух разных интерфейсов (Customer и Contact) и представить их в едином интерфейсе (RowItem)
   - Это классическая задача для паттерна Адаптер

2. **Шаги решения**:
   - Создать класс-адаптер, реализующий целевой интерфейс (RowItem)
   - В конструктор передать адаптируемые объекты (Customer и Contact)
   - Для каждого метода целевого интерфейса:
     * Определить, откуда брать данные (Customer или Contact)
     * При необходимости преобразовать данные (например, имя или телефон)
     * Вернуть результат в требуемом формате

3. **Преобразования данных**:
   - Для страны: ищем код по названию в карте
   - Для имени: разбиваем строку по запятой
   - Для телефона: очищаем от нецифровых символов

## Ключевые моменты:

1. Адаптер позволяет работать с разными интерфейсами как с одним
2. Все преобразования данных инкапсулированы в адаптере
3. Клиентский код работает только с целевым интерфейсом, не зная о деталях адаптации

Такой подход часто используется при интеграции разных систем или библиотек, когда нужно согласовать их интерфейсы.
