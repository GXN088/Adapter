# Adapter
# Подробный комментарий к коду с объяснением

```java
package com.javarush.task.task19.task1905;

import java.util.HashMap;
import java.util.Map;

/* 
Закрепляем адаптер
*/

public class Solution {
    // Статическое поле - словарь стран, где ключ - код страны, значение - полное название
    public static Map<String, String> countries = new HashMap<String, String>();

    // Статический блок инициализации для заполнения словаря стран
    static {
        countries.put("UA", "Ukraine");  // Украина
        countries.put("RU", "Russia");    // Россия
        countries.put("CA", "Canada");    // Канада
    }

    public static void main(String[] args) {
        // Основной метод пустой, так как задача демонстрационная
    }

    /**
     * Класс-адаптер, который преобразует интерфейсы Customer и Contact
     * в интерфейс RowItem (паттерн Adapter)
     */
    public static class DataAdapter implements RowItem {
        private Customer customer;  // Адаптируемый объект с информацией о клиенте
        private Contact contact;    // Адаптируемый объект с контактной информацией

        // Конструктор адаптера принимает оба адаптируемых объекта
        public DataAdapter(Customer customer, Contact contact) {
            this.customer = customer;
            this.contact = contact;
        }

        /**
         * Возвращает код страны клиента
         * Ищем в словаре countries по полному названию страны из Customer
         */
        @Override
        public String getCountryCode() {
            for (Map.Entry<String, String> entry : countries.entrySet()) {
                if (entry.getValue().equals(customer.getCountryName())) {
                    return entry.getKey();  // Возвращаем код страны (UA, RU, CA)
                }
            }
            return null;  // Если страна не найдена
        }

        /**
         * Возвращает название компании клиента
         * Просто делегируем вызов customer.getCompanyName()
         */
        @Override
        public String getCompany() {
            return customer.getCompanyName();
        }

        /**
         * Возвращает имя контакта
         * Контактное имя хранится в формате "Фамилия, Имя"
         * Разделяем строку по запятой и пробелу и берем вторую часть
         */
        @Override
        public String getContactFirstName() {
            String[] name = contact.getName().split(", ");
            return name[1];  // Имя (вторая часть после разделения)
        }

        /**
         * Возвращает фамилию контакта
         * Аналогично имени, но берем первую часть разделенной строки
         */
        @Override
        public String getContactLastName() {
            String[] name = contact.getName().split(", ");
            return name[0];  // Фамилия (первая часть после разделения)
        }

        /**
         * Возвращает строку для звонка
         * Преобразует телефонный номер в формат callto://+XXXXXXXXXX
         * Удаляет все нецифровые символы из номера (регулярное выражение \\D)
         */
        @Override
        public String getDialString() {
            return "callto://+" + contact.getPhoneNumber().replaceAll("\\D", "");
        }
    }

    /**
     * Целевой интерфейс, который мы хотим получить после адаптации
     * Определяет методы для получения:
     * - кода страны
     * - названия компании
     * - имени контакта
     * - фамилии контакта
     * - строки для звонка
     */
    public interface RowItem {
        String getCountryCode();        // Например: UA
        String getCompany();            // Например: JavaRush Ltd.
        String getContactFirstName();   // Например: Ivan
        String getContactLastName();    // Например: Ivanov
        String getDialString();         // Например: callto://+380501234567
    }

    /**
     * Интерфейс клиента (один из адаптируемых интерфейсов)
     * Содержит информацию о компании и стране
     */
    public interface Customer {
        String getCompanyName();        // Например: JavaRush Ltd.
        String getCountryName();        // Например: Ukraine
    }

    /**
     * Интерфейс контакта (второй адаптируемый интерфейс)
     * Содержит имя (в формате "Фамилия, Имя") и номер телефона
     */
    public interface Contact {
        String getName();               // Например: Ivanov, Ivan
        String getPhoneNumber();        // Например: +38(050)123-45-67
    }
}
```

## Как понять и реализовать такой адаптер:

1. **Определите интерфейсы**:
   - Целевой интерфейс (`RowItem`) - какой интерфейс вам нужен
   - Адаптируемые интерфейсы (`Customer` и `Contact`) - что у вас есть

2. **Создайте класс-адаптер**:
   - Реализуйте целевой интерфейс
   - Добавьте поля для хранения адаптируемых объектов
   - Создайте конструктор для их инициализации

3. **Реализуйте методы адаптера**:
   - Для каждого метода целевого интерфейса определите:
     * Откуда брать данные (какой из адаптируемых объектов)
     * Какие преобразования нужны
   - Примеры преобразований:
     * Поиск кода страны по названию
     * Разделение полного имени на части
     * Очистка номера телефона от лишних символов

4. **Использование адаптера**:
   - Клиентский код работает только с `RowItem`
   - Адаптер скрывает все преобразования и работу с разными интерфейсами

Такой подход особенно полезен при:
- Интеграции с внешними библиотеками
- Рефакторинге устаревшего кода
- Согласовании интерфейсов разных модулей системы

# Анализ кода задачи "Закрепляем адаптер"

Этот код демонстрирует паттерн "Адаптер" (Adapter), который позволяет интерфейсам работать вместе, когда они изначально несовместимы.

## Объяснение кода:

1. **Статическая карта countries**:
   ```java
   public static Map<String, String> countries = new HashMap<String, String>();
   ```
   Содержит соответствия кодов стран (UA, RU, CA) их полным названиям. Инициализируется в статическом блоке.

2. **Интерфейсы**:
   - `RowItem` - целевой интерфейс, который мы хотим получить
   - `Customer` и `Contact` - существующие интерфейсы, которые нужно адаптировать

3. **Класс DataAdapter**:
   Это собственно адаптер, который реализует целевой интерфейс `RowItem` и использует объекты `Customer` и `Contact` для получения данных.

## Методы адаптера:

1. **getCountryCode()**:
   - Ищет в карте countries код страны по её полному названию из Customer
   - Возвращает код (например, "UA" для "Ukraine")

2. **getCompany()**:
   - Просто возвращает название компании из Customer

3. **getContactFirstName()** и **getContactLastName()**:
   - Разбивают строку имени из Contact (формат "Фамилия, Имя")
   - Возвращают соответствующую часть

4. **getDialString()**:
   - Форматирует телефонный номер из Contact
   - Удаляет все нецифровые символы (`\\D`)
   - Добавляет префикс "callto://+"

## Как додуматься до такого решения:

1. **Анализ требований**:
   - Нужно получить данные из двух разных интерфейсов (Customer и Contact) и представить их в едином интерфейсе (RowItem)
   - Это классическая задача для паттерна Адаптер

2. **Шаги решения**:
   - Создать класс-адаптер, реализующий целевой интерфейс (RowItem)
   - В конструктор передать адаптируемые объекты (Customer и Contact)
   - Для каждого метода целевого интерфейса:
     * Определить, откуда брать данные (Customer или Contact)
     * При необходимости преобразовать данные (например, имя или телефон)
     * Вернуть результат в требуемом формате

3. **Преобразования данных**:
   - Для страны: ищем код по названию в карте
   - Для имени: разбиваем строку по запятой
   - Для телефона: очищаем от нецифровых символов

## Ключевые моменты:

1. Адаптер позволяет работать с разными интерфейсами как с одним
2. Все преобразования данных инкапсулированы в адаптере
3. Клиентский код работает только с целевым интерфейсом, не зная о деталях адаптации

Такой подход часто используется при интеграции разных систем или библиотек, когда нужно согласовать их интерфейсы.
